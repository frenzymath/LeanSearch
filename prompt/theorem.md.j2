{% from "lib.j2" import format_input %}
# Prompt for mathlib translator

Suppose you are an expert mathematician and an expert in Lean and Mathlib.

1. Your task is to first translate the formal theorem provided below into an informal statement that is more accessible to mathematicians written in Latex. There are four parts of information attached to the theorem.

   * Head statements, including important statements, theorems, definitions of the mathematical field the theorem in.
   * Docstrings. In most cases, the docstrings contains the informal explanation of the formal statement, written by human. In this case, you should make good use of the docstrings and include all mathematical information in the docstrings in your translation of statement. Sometimes the docstring also contains implementation notes, which should not appear in your translation.
   * Neighbor statements that are next to the given statement.
   * Dependent definitions or statements used in the theorem.

   Utilize these information to better understand the formal theorem. Make sure you follow the principles of informal statement when you translate the formal theorem into informal statement.

2. Then create an informal name. Use the provided formal name of the statement according to the naming conventions. Utilize the informal statement written in the first task. Make sure you follow the principles of informal name when you create an informal names. Principles of informal statement should also be conformed as possible as you can.

## Principles of informal statement

1. The informal statement should be written in human-used mathematical notations and formulas in latex as much as possible, and explain the meaning of the symbols therein. Explain more detailed mathematical setup only if the definition appeared in the statement is not commonly accepted. Both of conditions and conclusions should be expressed using mathematical formulas as much as possible.
  Example:
  DO NOT use "`Real.log`";
  Use "$\log$" instead.
2. DO NOT add any additional information that does not appear in the formal statement. The only exception is the explanation of an unfamiliar definition in the statement.
  Example:
  DO NOT translate `cos Real.pi = -1` as "$\cos \pi = -1$. This follows from ...", the whole part "This follows from ..." should be deleted since it does not appear in the statement.
  Leave only the part "$\cos \pi = -1$".

## Principles of informal name

1. Emphasize the core concepts in the theorem. The definition name should not merely list concepts; Use words that indicate logical relationships and clearly state the conclusion.
  Example:
  Use "A equals to B" or "A implies B" (or simply "$A = B$" and "$A \to B$"), instead of "theorem of A and B" when the theorem states the result of `A = B` or `A → B`.
2. Be as concise as possible on this basis. Use mathematical formulas in the informal name if possible.
  Example:
  "$\pi > 3$" is concise name for `theorem Real.pi_gt_three`.

**Warning: The following example is only used to demonstrate the format, their exact meaning is irrelevant.**

### Input 1:
**Head statements:**
# Helper "packing" theorems

**Kind:**
theorem
**Docstring:**

**Dependent statements:**
1.
Formal name: LT.lt
Formal statement: {α : Type u} → [self : LT α] → α → α → Prop
Informal name: Less Than Relation
Informal statement: The `LT.lt` function defines the 'less than' relation `<` for a given type `α` when the `LT α` typeclass is provided. It takes two arguments of type `α` and returns a proposition stating that the first argument is less than the second one.
2.
Formal name: Nat
Formal statement: Type
Informal name: Natural Numbers
Informal statement: The natural numbers are an inductive type, denoted as `Nat`, which is freely generated by two constructors: `zero`, representing the number 0, and `succ`, which represents the successor operation. This type is fundamental in Lean and is used for arithmetic and recursion. Theorems about natural numbers can be proven using induction, which involves proving the base case for `zero` and the inductive step for `succ`. The type `Nat` is optimized for efficiency, with small numbers represented directly and larger numbers using an arbitrary precision library.
3.
Formal name: instLTNat
Formal statement: LT Nat
Informal name: Less Than Relation Instance for Natural Numbers
Informal statement: For the natural numbers type `Nat`, there exists an instance of the `LT` typeclass, which provides a 'less than' relation `<` for elements of `Nat`. This relation is defined such that `n < m` holds if and only if the successor of `n` is less than or equal to `m`, i.e., `n + 1 ≤ m`.
4.
Formal name: instAddNat
Formal statement: Add Nat
Informal name: Addition Instance for Natural Numbers
Informal statement: For the natural numbers `Nat`, an instance of the `Add` structure is provided, which defines the addition operation for natural numbers. This instance allows the use of the `+` operator for adding natural numbers together, following the recursive definition where adding zero to any number results in the number itself, and adding the successor of a number results in the successor of the sum of the original numbers.
5.
Formal name: instHAdd
Formal statement: {α : Type u_1} → [inst : Add α] → HAdd α α α
Informal name: Heterogeneous Addition Instance for Additive Type
Informal statement: For any type \( alpha \) in universe level \( u_1 \) with an instance of the `Add` structure, there exists an instance of the `HAdd` structure for \( alpha \) that allows for heterogeneous addition operations between elements of \( alpha \) itself.
6.
Formal name: HAdd.hAdd
Formal statement: {α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAdd α β γ] → α → β → γ
Informal name: Heterogeneous Addition Operation
Informal statement: The function `hAdd` is the primary operation of the `HAdd` structure, which defines a heterogeneous addition. Given types `α`, `β`, and `γ` from the Lean universe hierarchy, `hAdd` takes an element `a : α` and an element `b : β`, and returns an element `a + b : γ`. This operation allows for the addition of elements from different types, extending the concept of addition beyond homogeneous types.
**Neighbor statements:**
1.
Formal name: Nat.add_lt_add_left
Formal statement: ∀ {n m : Nat}, n < m → ∀ (k : Nat), k + n < k + m
Informal name: Addition Preserves 'Less Than' Relation in Natural Numbers
Informal statement: For any natural numbers $n$ and $m$, if $n$ is strictly less than $m$, then for any natural number $k$, the sum of $k$ and $n$ is strictly less than the sum of $k$ and $m$. This theorem demonstrates the preservation of the 'less than' relation when adding a constant $k$ to both sides of the inequality in the natural numbers.
2.
Formal name: Nat.zero_lt_one
Formal statement: 0 < 1
Informal name: Zero is Less Than One in Natural Numbers
Informal statement: In the natural numbers, zero is strictly less than one.
**Similar translation examples:**
1.
Formal name: Nat.lt
Formal statement: Nat → Nat → Prop
Informal name: Strict Less-Than Relation on Natural Numbers
Informal statement: The strict less than relation on natural numbers is defined as `n < m := n + 1 ≤ m`.
2.
Formal name: Nat.dvd_add_self_right
Formal statement: ∀ {m n : ℕ}, m ∣ n + m ↔ m ∣ n
Informal name: Divisibility of Sum by Another Number in Natural Numbers
Informal statement: A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.
3.
Formal name: PartENat.coe_lt_coe
Formal statement: ∀ {x y : ℕ}, ↑x < ↑y ↔ x < y
Informal name: Preservation of 'Less Than' Relation in Casting Natural Numbers to Extended Natural Numbers
Informal statement: Alias of `Nat.cast_lt` specialized to `PartENat` -

**Formal name:**
Nat.add_lt_add_right
**Formal statement:**
∀ {n m : Nat}, n < m → ∀ (k : Nat), n + k < m + k

### Output 1:
**Informal statement:**
For any natural numbers $n$ and $m$ such that $n < m$, and for any natural number $k$, it holds that $n + k < m + k$.
**End of informal statement**
**Informal name:**
Right Addition Preserves Strict Inequality in Natural Numbers

### Now, your input is:
{{ format_input(input) }}
